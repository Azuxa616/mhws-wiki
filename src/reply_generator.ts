// 格式化怪物数据为文字消息
export function formatMonsterData(monster: any): string {
    let result = `【${monster.name}】\n`
    
    if (monster.description) {
      result += `描述: ${monster.description}\n\n`
    }
    
    if (monster.base_data) {
      result += '【基础数据】\n'
      for (const [key, value] of Object.entries(monster.base_data)) {
        result += `${key}: ${value}\n`
      }
      result += '\n'
    }
    
    if (monster.hitzone_data && monster.hitzone_data.length) {
      result += '【弱点数据】\n'
      for (const hitzone of monster.hitzone_data) {
        // 将所有列固定宽度，实现对齐效果
        const column0 = hitzone.部位 || '';
        const paddedColumn0 = column0.padEnd(4, ' ');
        
        const column1 = hitzone.列1?`(${hitzone.列1})` : '      ';
        const paddedColumn1 = column1.padEnd(5, ' ');
        
        const column2 = hitzone.列2 || '?';
        const paddedColumn2 = column2.padEnd(4, ' ');
        
        const column3 = hitzone.列3 || '?';
        const paddedColumn3 = column3.padEnd(4, ' ');
        
        const column4 = hitzone.列4 || '?';
        const paddedColumn4 = column4.padEnd(4, ' ');
        
        const column5 = hitzone.列5 || '?';
        const paddedColumn5 = column5.padEnd(3, ' ');
        
        const column6 = hitzone.列6 || '?';
        const paddedColumn6 = column6.padEnd(3, ' ');
        
        const column7 = hitzone.列7 || '?';
        const paddedColumn7 = column7.padEnd(3, ' ');
        
        const column8 = hitzone.列8 || '?';
        const paddedColumn8 = column8.padEnd(3, ' ');
        
        const column9 = hitzone.列9 || '?';
        const paddedColumn9 = column9.padEnd(3, ' ');
        
        const column10 = hitzone.列10 || '?';
        
        result += `${paddedColumn0}  ${paddedColumn1}  斩击${paddedColumn2}钝击${paddedColumn3}弹吸收${paddedColumn4}火${paddedColumn5}水${paddedColumn6}雷${paddedColumn7}冰${paddedColumn8}龙${paddedColumn9}晕眩${column10}\n`
      }
      result += '\n'
    }
    
    if (monster.materials && monster.materials.length) {
      result += '【素材掉落】\n'
      for (const material of monster.materials) {
        result += `${material.name}: ${material.description} (${material.rate})\n`
      }
    }
    
    return result
  }

/**
 * 使用通用方法绘制怪物信息到画布上
 * @param context Canvas的2D上下文
 * @param lines 文本行
 * @param width 画布宽度
 * @param height 画布高度
 */
function drawMonsterDataToContext(context: any, lines: string[], width: number, height: number) {
  const fontSize = 16;
  const lineHeight = fontSize * 1.5;
  const padding = 20;
  
  // 设置背景
  context.fillStyle = '#ffffff';
  context.fillRect(0, 0, width, height);
  
  // 添加边框
  context.strokeStyle = '#cccccc';
  context.lineWidth = 2;
  context.strokeRect(5, 5, width - 10, height - 10);
  
  // 设置文本样式
  context.font = `${fontSize}px "Microsoft YaHei", "微软雅黑", Arial, sans-serif`;
  context.fillStyle = '#000000';
  context.textBaseline = 'top';
  
  // 绘制每一行文本
  let yPos = padding;
  for (const line of lines) {
    // 特殊处理标题、分类标题
    if (line.startsWith('【') && line.endsWith('】')) {
      context.font = `bold ${fontSize + 2}px "Microsoft YaHei", "微软雅黑", Arial, sans-serif`;
      context.fillStyle = '#0066cc';
    } else if (line.includes('：') || line.includes(':')) {
      context.font = `${fontSize}px "Microsoft YaHei", "微软雅黑", Arial, sans-serif`;
      context.fillStyle = '#333333';
    } else {
      context.font = `${fontSize}px "Microsoft YaHei", "微软雅黑", Arial, sans-serif`;
      context.fillStyle = '#000000';
    }
    
    context.fillText(line, padding, yPos);
    yPos += lineHeight;
  }
  
  // 添加页脚
  context.font = `${fontSize - 4}px "Microsoft YaHei", "微软雅黑", Arial, sans-serif`;
  context.fillStyle = '#999999';
  context.fillText('Generated by MHWS-Wiki Plugin', padding, height - padding);
}

// 格式化怪物数据，生成图片
export async function formatMonsterDataToImage(monster: any, ctx: any): Promise<Buffer> {
  try {
    // 获取文本内容
    const textContent = formatMonsterData(monster);
    
    // 使用canvas
    const canvas = ctx.canvas;
    if (!canvas) {
      throw new Error('Canvas服务不可用');
    }
    
    // 计算图片尺寸
    const lines = textContent.split('\n');
    const maxLineLength = Math.max(...lines.map(line => line.length));
    if (maxLineLength <= 0 || lines.length <= 0) {
      throw new Error('怪物数据为空');
    }
    
    // 设置图片宽高
    const fontSize = 16;
    const lineHeight = fontSize * 1.5;
    const padding = 20;
    const width = Math.max(400, maxLineLength * fontSize * 0.6 + padding * 2); // 确保最小宽度为400px
    const height = Math.max(300, lines.length * lineHeight + padding * 2); // 确保最小高度为300px
    
    // 尝试加载常见的canvas模块
    try {
      // 检查是否使用的是通用canvas服务（比如@koishijs/canvas）
      if (typeof canvas.render === 'function') {
        // 对于一些提供render函数的canvas库，如@koishijs/canvas
        return await canvas.render({
          width,
          height,
          draw: (ctx: any) => {
            drawMonsterDataToContext(ctx, lines, width, height);
          }
        });
      }
      
      // 检查canvas是否有Canvas类（@napi-rs/canvas 常见模式）
      if (canvas.Canvas && typeof canvas.Canvas === 'function') {
        const canvasInstance = new canvas.Canvas(width, height);
        const context = canvasInstance.getContext('2d');
        
        drawMonsterDataToContext(context, lines, width, height);
        
        // @napi-rs/canvas 的 toBuffer 返回的是 Promise
        if (typeof canvasInstance.toBuffer === 'function') {
          if (canvasInstance.toBuffer.length > 0) { // 有参数的toBuffer
            return await canvasInstance.toBuffer('image/png');
          } else {
            // 无参数的toBuffer
            return await canvasInstance.toBuffer();
          }
        }
      }
      
      // 第一种方法：使用常规canvas API
      const canvasObj = canvas.createCanvas(width, height);
      
      // 检查是否canvasObj是一个函数，表示是画布对象本身
      if (typeof canvasObj.getContext === 'function') {
        const context = canvasObj.getContext('2d');
        
        drawMonsterDataToContext(context, lines, width, height);
        
        // 输出图片
        if (typeof canvasObj.toBuffer === 'function') {
          // 如果是Promise，等待其完成
          if (canvasObj.toBuffer.constructor.name === 'AsyncFunction' || 
              canvasObj.toBuffer().toString() === '[object Promise]') {
            return await canvasObj.toBuffer('image/png');
          } else {
            return canvasObj.toBuffer('image/png');
          }
        }
      } 
      // 第二种方法：有些canvas库直接返回context
      else if (typeof canvasObj.fillStyle !== 'undefined') {
        const context = canvasObj;
        
        drawMonsterDataToContext(context, lines, width, height);
        
        // 输出图片
        if (typeof canvas.toBuffer === 'function') {
          if (canvas.toBuffer.constructor.name === 'AsyncFunction' ||
              canvas.toBuffer().toString() === '[object Promise]') {
            return await canvas.toBuffer('image/png');
          } else {
            return canvas.toBuffer('image/png');
          }
        } else if (typeof canvasObj.toBuffer === 'function') {
          if (canvasObj.toBuffer.constructor.name === 'AsyncFunction' ||
              canvasObj.toBuffer().toString() === '[object Promise]') {
            return await canvasObj.toBuffer('image/png');
          } else {
            return canvasObj.toBuffer('image/png');
          }
        } else {
          throw new Error('Canvas接口不完整，无法生成图片');
        }
      }
      // 如果都不符合，尝试第三种方法：canvas可能是工厂函数
      else if (typeof canvas === 'function') {
        // canvas本身就是创建图像的函数
        const canvasInstance = canvas(width, height);
        if (canvasInstance && typeof canvasInstance.getContext === 'function') {
          const context = canvasInstance.getContext('2d');
          
          drawMonsterDataToContext(context, lines, width, height);
          
          // 输出图片
          if (typeof canvasInstance.toBuffer === 'function') {
            if (canvasInstance.toBuffer.constructor.name === 'AsyncFunction' ||
                canvasInstance.toBuffer().toString() === '[object Promise]') {
              return await canvasInstance.toBuffer('image/png');
            } else {
              return canvasInstance.toBuffer('image/png');
            }
          }
        }
      }
      
      throw new Error('不支持的Canvas API');
      
    } catch (error) {
      console.error('Canvas绘制错误:', error);
      throw new Error(`Canvas绘制错误: ${error.message}`);
    }
  } catch (error) {
    console.error('生成图片时出错:', error);
    throw error;
  }
}